import sys
import pickle
import cv2
import mediapipe as mp
import numpy as np
from PyQt5 import QtWidgets, QtGui, QtCore

# Configuración de MediaPipe
mp_hands = mp.solutions.hands
mp_drawing = mp.solutions.drawing_utils
mp_drawing_styles = mp.solutions.drawing_styles
hands = mp_hands.Hands(static_image_mode=True, min_detection_confidence=0.3)

class VideoWidget(QtWidgets.QLabel):
    def __init__(self):
        super().__init__()
        self.cap = cv2.VideoCapture(0)
        self.timer = QtCore.QTimer()
        self.timer.timeout.connect(self.update_frame)
        self.timer.start(30)
        model_dict = pickle.load(open('./model.p', 'rb'))
        self.model = model_dict['model'] 
        

        self.setMinimumSize(640, 480)  # Cambia el tamaño según lo necesites
        # Establecer un tamaño máximo para el widget de video (opcional)
        self.setMaximumSize(1024, 768)  # Cambia el tamaño según lo necesites

    def update_frame(self):
        ret, frame = self.cap.read()
        if not ret:
            return

        # Procesamiento de MediaPipe
        frame_rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
        results = hands.process(frame_rgb)

        if results.multi_hand_landmarks:
            for hand_landmarks in results.multi_hand_landmarks:
                mp_drawing.draw_landmarks(
                    frame,
                    hand_landmarks,
                    mp_hands.HAND_CONNECTIONS,
                    mp_drawing_styles.get_default_hand_landmarks_style(),
                    mp_drawing_styles.get_default_hand_connections_style()
                )

                # Recolección de datos para el modelo
                data_aux = []
                x_ = []
                y_ = []

                for landmark in hand_landmarks.landmark:
                    x_.append(landmark.x)
                    y_.append(landmark.y)

                for landmark in hand_landmarks.landmark:
                    data_aux.append(landmark.x - min(x_))
                    data_aux.append(landmark.y - min(y_))

                if self.model is not None:  # Solo predice si el modelo está cargado
                    prediction = self.model.predict([np.asarray(data_aux)])
                    predicted_character = prediction[0]

                    # Dibujar resultado
                    cv2.putText(frame, predicted_character, (30, 50), cv2.FONT_HERSHEY_SIMPLEX, 1.3, (0, 255, 0), 3)

        # Convertir imagen para PyQt
        frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
        h, w, ch = frame.shape
        bytes_per_line = ch * w
        qt_img = QtGui.QImage(frame.data, w, h, bytes_per_line, QtGui.QImage.Format_RGB888)
        self.setPixmap(QtGui.QPixmap.fromImage(qt_img))

    def closeEvent(self, event):
        self.cap.release()
        event.accept()

class MainWindow(QtWidgets.QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Reconocimiento de Gestos")
        self.setGeometry(100, 100, 800, 600)

        # Widget de video
        self.video_widget = VideoWidget()
        self.video_widget.setAlignment(QtCore.Qt.AlignCenter)  # Centrar el video

        # Botones y menú desplegable en la parte inferior
        self.btn_iniciar = QtWidgets.QPushButton("Iniciar")

        # Menú desplegable
        self.combo_opciones = QtWidgets.QComboBox()
        self.combo_opciones.addItems(["ABECEDARIO", "NUMEROS"])  # Agrega las opciones al desplegable

        # Eventos de botones
        self.btn_iniciar.clicked.connect(self.iniciar_funcion)
        self.combo_opciones.currentTextChanged.connect(self.opcion_seleccionada)

        # Layouts
        layout_principal = QtWidgets.QVBoxLayout()
        layout_principal.addWidget(self.video_widget, alignment=QtCore.Qt.AlignCenter)  # Centrar el video en el layout

        layout_botones = QtWidgets.QHBoxLayout()
        layout_botones.addWidget(self.btn_iniciar)
        layout_botones.addWidget(self.combo_opciones)
        layout_principal.addLayout(layout_botones)

        self.setLayout(layout_principal)

    def iniciar_funcion(self):
        print("Botón 'Iniciar' presionado")

    def opcion_seleccionada(self, opcion):
        # Condiciones según la opción seleccionada
        if opcion == "ABECEDARIO":
            model_dict = pickle.load(open('./model.p', 'rb'))
            self.video_widget.model = model_dict['model']  # Carga el modelo correspondiente
            print("Modelo de Abecedario cargado.")
        elif opcion == "NUMEROS":
            model_dict = pickle.load(open('./model_numerico.p', 'rb'))
            self.video_widget.model = model_dict['model']  # Carga el modelo correspondiente
            print("Modelo de Números cargado.")

app = QtWidgets.QApplication(sys.argv)
window = MainWindow()
window.show()
sys.exit(app.exec_())
